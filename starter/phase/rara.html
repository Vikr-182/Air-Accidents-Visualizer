<!DOCTYPE html>
<head>
<meta charset="utf-8">
<style>
    circle {
        stroke-width: 1.5px;
    }

    line {
        stroke: #999;
    }
</style>
</head>
<body>
    <script src="https://d3js.org/queue.v1.min.js"></script>
    <script src="https://d3js.org/d3.v4.min.js"></script>
    <script>
        var width = 1500,
            height = 600,
            radius = 6;

       

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height);

        var middl = height/1.5;
        var init = {
            " Taxi (TXI)":{"start":0,"next":0,"width":10,"xst":0,"xwid":width/7,"k":0},
            " Takeoff (TOF)":{"start":0,"next":100,"width":100,"xst":width/7,"xwid":width/7,"k":1},
                " Initial climb (ICL)":{"start":100,"next":middl,"width":100,"xst":2*width/7,"xwid":width/7,"k":2},
                " En route (ENR)": {"start":middl,"next":middl,"width":150,"xst":3*width/7,"xwid":width/7,"k":3},
                " Approach (APR)": {"start":100,"next":middl,"width":100,"xst":4*width/7,"xwid":width/7,"k":4},
                " Landing (LDG)": {"start":0,"next":100,"width":150 ,"xst":5*width/7,"xwid":width/7,"k":5},
                " Kyra": {"start":0,next:0,"width":40,"xst":6*width/7,"xwid":width/7,"k":6}
        }


        queue()
        .defer(d3.json, "graph.json")
        .defer(d3.json,"cleaned_data.json")
        .await(ready)


        function give_me_x(phase){
            if(!Object.keys(init).includes(phase)){
                phase = " Kyra"                
            }
            return [init[phase]["xst"],init[phase]["xwid"]]
        }   

        function give_me_y(x,k,phase){
            if(!Object.keys(init).includes(phase)){
                phase = " Kyra";
            }
            if(k == 0 || k == 3 || k == 6)
            {
                    // taxi or enroute, return y = c
                    return  [init[phase]["start"],init[phase]["start"] +  init[phase]["width"]]
                }
                else if (k == 1 || k == 5){
                    // takeoff or landing , return y = a . x^2 
                    x = x - width / 7;
                    var a = init[phase]["next"]*49 / (width*width);
                    var y = a * x * x;
                    return [y,y +  init[phase]["width"]];
                }
                else{
                    // climb or approach phase, return y = - a. (x - 2*x0) * x
                    x = x - 2*width / 7;
                    x0 = width / 7;
                    a = (init[phase]["next"] - init[phase]["start"]) / (width/7 * (width/7 - 2*x0));
                    y = a * (x - 2*x0) * x;
                    return [y + init[phase]["start"],y + init[phase]["start"] +  init[phase]["width"]];
                }
        }

        var ground = height;
        var array = [" Substantial", " Destroyed"," Damage beyond repair", " None", " Minor", " Unkown"," Missing"];
        function ready(error,graph,data_ra) {
            
            if (error) throw error;
            var ll;
            var new_graph = new Array(0);
            for(ll in data_ra){
                if( data_ra[ll]["date"].slice(0,4) == "2001" ||  data_ra[ll]["date"].slice(0,4) == "2000" || data_ra[ll]["date"].slice(0,4) == "2002" || data_ra[ll]["date"].slice(0,4) == "2003")
                new_graph.push({
                    "name": data_ra[ll]["date"],
                    "total": (data_ra[ll]["Total:"]).split("/"),
                    "fatalities": parseInt(data_ra[ll]["Total:"].split("/")[1].split(" ")[2]),
                    "occupants": parseInt(data_ra[ll]["Total:"].split("/")[0].split(" ")[1]),
                    "phase": data_ra[ll]["Phase:"]
                });
            }
            var maxi = d3.max(new_graph, function (d) {return d["fatalities"]});
            for(var j = 0; j < ((new_graph.length));j++)
            {
                new_graph[j]["radius"] = 4 + 20 * new_graph[j]["fatalities"]/maxi;
            }
            // console.log(new_graph)
            var node = svg.selectAll("circle")
                .data(new_graph)
                .enter().append("circle")
                .attr("r", function(d){
                    return d["radius"];
                })
                .style("fill", function(d){
                    return "white";
                })
                .style("stroke","black")

        var collisionForce = d3.forceCollide(12);
        var simulation = d3.forceSimulation()
            .force("charge",  d3.forceManyBody().strength(-20))
            .force("collision",collisionForce.radius(function(d){
                return d["radius"];
            }))
            .nodes(new_graph)
            .on("tick", tick);


            function tick() {
                node.attr("cx", function (d) {
                        // console.log(give_me_x(d["phase"]));
                         d.x = Math.max(give_me_x(d["phase"])[0] + radius , Math.min(give_me_x(d["phase"])[0] + give_me_x(d["phase"])[1] - radius, d.x ));
                         if( d.x  == (give_me_x(d["phase"])[0] + radius ) || d.x == give_me_x(d["phase"])[0] + give_me_x(d["phase"])[1] - radius){
                             // place it randomly
                            //  alert(give_me_x(d["phase"])[0] + radius  + Math.random()*width/7);
                             return d.x = give_me_x(d["phase"])[0] + radius  + Math.random()*width/7;
                         }
                         return d.x;
                    })
                    .attr("cy", function (d) {
                    xx = d.x;
                    if (d['phase'] == " Taxi (TXI)")
                    {
                        // console.log("iffing at =** ") 
                        // alert(give_me_y(xx,0,d["phase"])[1]);
                        d.y = Math.min(ground - give_me_y(xx,0,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,0,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,0,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,0,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,0,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,0,d["phase"])[1] - give_me_y(xx,0,d["phase"])[0]);
                        }
                        return d.y;
                    }
                    if (d['phase'] == " Takeoff (TOF)"){
                        // console.log("iffing at =** ")
                        d.y = Math.min(ground - give_me_y(xx,1,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,1,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,1,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,1,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,1,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,1,d["phase"])[1] - give_me_y(xx,1,d["phase"])[0]);
                        }
                        return d.y;
                    }
                    if (d['phase'] == " Initial climb (ICL)"){
                        // console.log("iffing at =** ") 
                        d.y = Math.min(ground - give_me_y(xx,2,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,2,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,2,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,2,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,2,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,2,d["phase"])[1] - give_me_y(xx,2,d["phase"])[0]);
                        }
                        return d.y ;//= Math.min(ground - give_me_y(xx,2,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,2,d["phase"])[1] - radius,d.y));
                    }
                    if (d['phase'] == " En route (ENR)"){
                        // console.log("iffing at =** ") 
                        d.y = Math.min(ground - give_me_y(xx,3,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,3,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,3,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,3,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,3,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,3,d["phase"])[1] - give_me_y(xx,3,d["phase"])[0]);
                        }
                        return d.y;
                    }
                    if (d['phase'] == " Approach (APR)"){
                        // console.log("iffing at =** ") 
                        xx = width - xx;
                        d.y = Math.min(ground - give_me_y(xx,4,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,4,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,4,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,4,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,4,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,4,d["phase"])[1] - give_me_y(xx,4,d["phase"])[0]);
                        }
                        return d.y;
                    }
                    if (d['phase'] == " Landing (LDG)"){
                        // console.log("iffing at =** ") 
                        xx = width - xx;
                        d.y = Math.min(ground - give_me_y(xx,5,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,5,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,5,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,5,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,5,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,5,d["phase"])[1] - give_me_y(xx,5,d["phase"])[0]);
                        }
                        return d.y;
                    }            
                    else{
                        xx = width - xx;
                        d.y = Math.min(ground - give_me_y(xx,6,d["phase"])[0] - radius, Math.max(ground - give_me_y(xx,6,d["phase"])[1] - radius,d.y));    
                        if( d.y == ground - give_me_y(xx,6,d["phase"])[0] - radius || d.y == ground - give_me_y(xx,6,d["phase"])[1] - radius){
                            d.y = ground - give_me_y(xx,6,d["phase"])[0] - radius -  Math.random() * (give_me_y(xx,6,d["phase"])[1] - give_me_y(xx,6,d["phase"])[0]);
                        }
                        return d.y;
                    }
                        

                    });

            }
        };

        function dragstarted(d) {
            if (!d3.event.active) simulation.alphaTarget(0.3).restart();
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(d) {
            d.fx = d3.event.x;
            d.fy = d3.event.y;
        }

        function dragended(d) {
            if (!d3.event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }
    </script>
</body>